\documentclass[a4paper,twocolumn,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath} % align environment
\usepackage{mathptmx} % times roman, including math
\usepackage{bussproofs} % notation for inference rules
\usepackage[hyphens]{url}
\usepackage{doi}
\usepackage{hyperref}
\usepackage[numbers,sort]{natbib}
\hyphenation{da-ta-cen-ter da-ta-cen-ters time-stamp}
\frenchspacing

\newcommand{\evalto}{\;\Longrightarrow\;}

% Placeholder character like \textvisiblespace, but works in math mode
\newcommand{\placeholder}{%
  \makebox[0.7em]{%
    \kern.07em
    \vrule height.3ex
    \hrulefill
    \vrule height.3ex
    \kern.07em
  }%
}

\begin{document}
\sloppy
\title{Composing Data Structures for Collaborative Document Editing}
\author{}
\maketitle

\subsection*{Abstract}

\section{Introduction}

CRDTs~\cite{Shapiro:2011wy,Roh:2011dw}

\section{Operational Semantics}

We assume that each peer has a unique identifier (for example, the hash of its public key). Whenever an edit to a document is made at one of the peers, we generate a unique identifier for that edit operation using Lamport timestamps~\cite{Lamport:1978jq}.

A Lamport timestamp is a pair $(c, p)$ where $p$ is the unique identifier of the peer on which the edit is made. $c$ is a counter that is stored at each peer and incremented for every operation. Whenever an operation is sent to other peers, the Lamport timestamp $(c, p)$ for that operation is included in the message.

If a peer receives an operation with a counter value $c$ that is greater than the locally stored counter value, the local counter is increased to the value of the incoming counter. This ensures that if operation $o_1$ happened before $o_2$ (that is, the peer that generated $o_2$ had received and processed $o_1$ before $o_2$ was generated), then $o_2$ must have a greater counter value than $o_1$. Only concurrent operations can have equal counter values.

We can thus define a total ordering $<$ for Lamport timestamps:
$$(c_1, p_1) < (c_2, p_2) \;\text{ iff }\; (c_1 < c_2) \vee (c_1 = c_2 \wedge p_1 < p_2).$$
If one operation happened before another, this ordering is consistent with causality (the earlier operation has a lower timesetamp). If two operations are concurrent, their order according to $<$ is arbitrary but deterministic.

\subsection{Ordered List Operations}

The \emph{Replicated Growable Array} (RGA) datatype was originally defined by Roh et al.\ using pseudocode~\cite{Roh:2011dw}. In this section we present the algorithm in an alternative form which is more amenable to correctness proofs.

Each peer that maintains a replica of an RGA stores a copy of its state $A$, which is a partial function from $\mathit{id}$ to pairs of $(\mathit{value}, \mathit{next})$. The parameter $\mathit{id}$ is either a Lamport timestamp or the special symbol $\mathsf{head}$, indicating the head of the list. $\mathit{next}$ is either a Lamport timestamp or the symbol $\mathsf{tail}$, denoting the end of the list. $\mathit{value}$ is any value of the datatype of list elements, or the special value $\bot$, indicating the absence of a value.

The empty list $A_\emptyset$ is represented as a function whose domain is the single value $\mathsf{head}$:
$$ A_\emptyset = \{\mathsf{head} \mapsto (\bot, \mathsf{tail})\}. $$

We use the notation $A[\,a \mapsto (b, c)\,]$ to denote a function identical to $A$, except that $A(a)=(b,c)$.

A list element is created with an $\mathsf{insert}$ operation. Since each operation has a Lamport timestamp, a list element is uniquely identified by its timestamp, which remains immutable for the lifetime of the document. We call that Lamport timestamp the ID of the list element.

The operation $\mathsf{insert}(\mathit{id}, \mathit{prev}, v)$ is an instruction to insert the value $v$ into a list at a position following the existing list element with ID $\mathit{prev}$. An insertion at the head of the list is expressed as $\mathsf{insert}(\mathit{id}, \mathsf{head}, v)$. The $\mathit{id}$ is the unique ID of this operation.

\begin{figure*}
\centering
\AxiomC{$c = A_p(\mathsf{ctr})$}
\AxiomC{$p = \mathrm{myPeerID()}$}
\LeftLabel{\textsc{Gen-TS}}
\BinaryInfC{$A_p,\; \mathsf{newID} \evalto A_p[\,\mathsf{ctr} \mapsto c+1\,],\; (c+1, p)$}
\DisplayProof\hfill
%
\AxiomC{$\mathit{id} = (c, p_\mathit{id})$}
\LeftLabel{\textsc{Apply-TS}}
\UnaryInfC{$A_p,\; \mathsf{ts}(\mathit{id}) \evalto
    A_p[\,\mathsf{ctr} \mapsto \mathrm{max}(A(\mathsf{ctr}), c)\,]$}
\DisplayProof



\begin{prooftree}
    \AxiomC{$\mathit{id} \not\in \mathrm{dom}(A_p)$}
    \AxiomC{$A_p(\mathit{prev}) = \mathsf{listEl}(v_\mathit{prev}, \mathit{next})$}
    \AxiomC{$\mathit{next} < \mathit{id}$}
    \AxiomC{$A_p,\; \mathsf{ts}(\mathit{id}) \evalto A_p'$}
    \LeftLabel{$\textsc{Apply-Ins}_1$}
    \QuaternaryInfC{$A_p,\; \mathsf{insert}(\mathit{id}, \mathit{prev}, v) \evalto
        A_p'[\,\mathit{prev} \mapsto \mathsf{listEl}(v_\mathit{prev}, \mathit{id}),\;
        \mathit{id} \mapsto \mathsf{listEl}(v, \mathit{next})\,]$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$A_p(\mathit{prev}) = \mathsf{listEl}(v_\mathit{prev}, \mathit{next})$}
    \AxiomC{$\mathit{id} < \mathit{next}$}
    \AxiomC{$A_p,\; \mathsf{insert}(\mathit{id}, \mathit{next}, v) \evalto A_p'$}
    \LeftLabel{$\textsc{Apply-Ins}_2$}
    \TrinaryInfC{$A_p,\; \mathsf{insert}(\mathit{id}, \mathit{prev}, v) \evalto A_p'$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$A_p(\mathit{target}) = \mathsf{listEl}(v, \mathit{next})$}
    \AxiomC{$A_p,\; \mathsf{ts}(\mathit{id}) \evalto A_p'$}
    \LeftLabel{\textsc{Apply-Del}}
    \BinaryInfC{$A_p,\; \mathsf{delete}(\mathit{id}, \mathit{target}) \evalto
        A_p'[\,\mathit{target} \mapsto \mathsf{listEl}(\bot, \mathit{next})\,]$}
\end{prooftree}
\caption{Rules for mutating an ordered list}
\label{fig:rga-rules}
\end{figure*}

When the operation is applied to the list state $A$, it produces a modified list state $A'$ as follows:
\begin{align*}
A' &= \mathrm{apply}(A, \mathsf{insert}(\mathit{id}, \mathit{prev}, v)) \\ &=
\begin{cases}
\quad \mathrm{apply}(A, \mathsf{insert}(\mathit{id}, n, v)) \\
    \qquad\quad\text{if }\; A(\mathit{prev}) = (\placeholder, n) \;\wedge\; \mathit{id} < n \\
\quad A[\,\mathit{prev} \mapsto (v_p, \mathit{id}),\; \mathit{id} \mapsto (v, n)\,] \\
    \qquad\quad\text{if }\; A(\mathit{prev}) = (v_p, n) \;\wedge\; n < \mathit{id}
\end{cases}
\end{align*}
where $<$ is the total order on Lamport timestamps, with the additional requirement that $\mathsf{tail} < (c, p)$ and $\mathsf{head} < (c, p)$ for any Lamport timestamp $(c, p)$.

Applying an $\mathsf{insert}$ operation is like inserting an element into a linked list, except that the function first skips over list elements with an ID greater than the ID of the new element being inserted. This has the effect of deterministically ordering concurrent insertions made at the same position of the list. This property is proved formally below.

The operation $\mathsf{delete}(\mathit{id})$ is an instruction to delete the element with ID $\mathit{id}$ from the list. The operation has the following semantics:
\begin{align*}
A' &= \mathrm{apply}(A, \mathsf{delete}(\mathit{id})) \\ &=
A[\,\mathit{id} \mapsto (\bot, n)\,]
\quad\text{if }\; A(\mathit{id}) = (\placeholder, n)
\end{align*}

The user view of a list A iterates over the list elements from $\mathsf{head}$ to $\mathsf{tail}$, skipping any deleted elements (tombstones):
\begin{align*}
\mathrm{view}(A) &= \mathrm{itr}(A, \mathsf{head}) \\
\mathrm{itr}(A, \mathit{id}) &= \begin{cases}
    [v] \mathbin{::} \mathrm{itr}(A, n) & \text{if }\; A(\mathit{id}) = (v, n) \;\wedge\; v \neq \bot \\
                     \mathrm{itr}(A, n) & \text{if }\; A(\mathit{id}) = (v, n) \;\wedge\; v = \bot \\
    [\,] & \text{if }\; \mathit{id} = \mathsf{tail}
\end{cases}
\end{align*}

\subsection{Convergence}

We now prove the convergence property, also known as \emph{eventual consistency}, for this data structure.

\textbf{Theorem.} If any two peers process the same set of $\mathsf{insert}$ and $\mathsf{delete}$ operations, in any causally consistent order (but not necessarily the same order), then their final states are identical.

\textbf{Proof.} Each peer processes operations in some sequential order, and the state of a peer is modified only by operations. Therefore, we can derive the state of peer $p$ from the history of operations $H_p=o_1 \dots o_n$ applied at that peer, processed in the order of the history:
$$ A_{H_p} = \mathrm{apply}(\mathrm{apply}(\dots \mathrm{apply}(A_\emptyset, o_1), \dots, o_{n-1}), o_n). $$

We can prove the theorem by induction over the length of the history $n$.

\emph{Base case:} A history of $n=0$ operations describes an empty document. An empty document is deterministically defined, so any two peers that have not executed any operations are by definition in the same state.

\emph{Induction step:} Given causal histories $H_1$ and $H_2$ of length $n$, such that $H_1=o_1 \dots o_n$ and $H_2$ is a permutation of $H_1$, and such that applying $H_1$ results in the same state as applying $H_2$, we can construct new histories of length $n+1$ by inserting an operation $o_{n+1}$ at any causally ready position in either $H_1$ or $H_2$. We must then show that for all of the histories constructed this way, applying the operations results in the same final state.

We show the induction step case by case, considering each type of operation $o_{n+1}$ that may be inserted.

\subsubsection{Commutativity of deletion}

First consider the case that $o_{n+1}=\mathsf{delete}(\mathit{id})$. A list element can only be deleted if it exists in the list, so by causality, there must exist an operation $o_i=\mathsf{insert}(\mathit{id}, \placeholder, \placeholder)$ at a prior point in the history. Moreover, the Lamport timestamp used as $\mathit{id}$ is unique, so there must be exactly one such $\mathsf{insert}$ operation, and there cannot be any $\mathsf{insert}$ operation for the same $\mathit{id}$ at a point after $o_{n+1}$ in the history.

Note that applying $\mathsf{delete}(\mathit{id})$ modifies only the mapping for $A(\mathit{id})$, and otherwise leaves the state $A$ unchanged, so it is trivially commutative with respect to any operation that does not modify or depend on $A(\mathit{id})$.

The first kind of operation that can modify the same $A(\mathit{id})$ is a $\mathsf{delete}$ operation for the same list element $\mathit{id}$. As the rule for applying this operation is idempotent, the presence of any other $\mathsf{delete}(\mathit{id})$ operations before or after $o_{n+1}$ in the history does not have any effect on the final state.

We showed that an $\mathsf{insert}(\mathit{id}, \placeholder, \placeholder)$ operation can only occur prior to $\mathsf{delete}(\mathit{id})$. Thus, the only other kind of operation that can depend on or modify $A(\mathit{id})$ is an $\mathsf{insert}(\placeholder, \mathit{id}, \placeholder)$ operation, or a recursive call to the $\mathrm{apply}$ function that uses such an operation internally. Note that when applying such an $\mathsf{insert}$ operation, the queries for $A(\mathit{prev})$ ignore the $\mathit{value}$ element of the tuple and leave it unchanged, and only examine and modify the $\mathit{next}$ element of the tuple. By contrast, applying $\mathsf{delete}(\mathit{id})$ modifies only the $\mathit{value}$ element of $A(\mathit{id})$, and leaves the $\mathit{next}$ element unchanged.

Thus, if $o_{n+1}=\mathsf{delete}(\mathit{id})$ is inserted at any causally ready point in a history, the final state does not depend on the insertion point, because the inserted operation does not interact with any prior or following operations.

\subsubsection{Commutativity of insertion}

Now consider the case that $o_{n+1}=\mathsf{insert}(\mathit{id}, \mathit{prev}, v)$. The Lamport timestamp $\mathit{id}$ is freshly generated by the peer on which the edit was performed. Let $p$ by the peer on which $o_{n+1}$ was generated, let $A_p$ be the state of $p$ immediately before $o_{n+1}$ was applied, and let $A_p'$ be the state of $p$ immediately after $o_{n+1}$ was applied.

By the definition of Lamport timestamps, $\mathit{id}$ is the greatest timestamp in $A_p'$, and greater than any timestamp occurring in $A_p$. Therefore, in the state update $A_p' = \mathrm{apply}(A_p, \mathsf{insert}(\mathit{id}, \mathit{prev}, v)),$ the non-recursive case ($n < \mathit{id}$) must apply. Therefore we have:
\begin{align*}
A_p' =\; & A_p[\,\mathit{prev} \mapsto (v_\mathit{prev}, \mathit{id}),\; \mathit{id} \mapsto (v, \mathit{next})\,] \\
\text{where}\quad & A_p(\mathit{prev}) = (v_\mathit{prev}, \mathit{next}) \\
& \mathit{prev} < \mathit{id} \quad\text{and}\quad \mathit{next} < \mathit{id}.
\end{align*}

The rules that modify a peer's state never remove an ID (i.e.\ the domain of the partial function $A$ monotonically grows as operations are applied). Thus, when $o_{n+1}$ is applied at another peer $q$ at any causally ready time in its history, $A_q(\mathit{prev})$ and $A_q(\mathit{next})$ must be defined in the state $A_q$, or $\mathit{next} = \mathsf{tail}$.

Note that the linked list structure is only modified by applying $\mathsf{insert}$ operations ($\mathsf{delete}$ operations modify values, but not the order of items in the list). Causal ordering requires $o_{n+1}$ to be applied after any operation that happened before, and before any operation that happened causally later, so we need only consider all possible orderings of $o_{n+1}$ with respect to other concurrent $\mathsf{insert}$ operations.

Moreover, the list structure is only modified by inserting a new element between two existing, adjacent elements. When $o_{n+1}$ is applied at peer $q$, the elements identified by $\mathit{prev}$ and $\mathit{next}$ are not necessarily adjacent in $A_q$, but we know that they must still be in the same order. According to the observation above, we also know that any other ID $\mathit{id}'$ inserted between those elements must have $\mathit{prev} < \mathit{id}'$ and $\mathit{next} < \mathit{id}'$.

By the induction hypothesis, let $H_1$ and $H_2$ be causal histories of operations $o_1 \dots o_n$ which result in the same final state when applied. When $o_{n+1}$ is inserted into either of these histories, causality demands that list elements $\mathit{prev}$ and $\mathit{next}$ were already inserted at some point in the history prior to $o_{n+1}$. When $o_{n+1}$ is applied, the $\mathrm{apply}(\placeholder, \mathsf{insert}(\mathit{id}, \mathit{prev}, v))$ rule starts iterating at $\mathit{prev}$ and skips over any elements with an ID greater than $\mathit{id}$. Since $\mathit{next} < \mathit{id}$, the recursion never continues beyond $\mathit{next}$. Thus, the $\mathrm{apply}$ rule is guaranteed to insert $\mathit{id}$ at some position between $\mathit{prev}$ and $\mathit{next}$.

Therefore, we need only consider insertions that are concurrent to $o_{n+1}$ and that insert at some position between $\mathit{prev}$ and $\mathit{next}$. Let $H_c$ be a history of operations, derived from either $H_1$ or $H_2$ by selecting only $\mathsf{insert}$ operations that are concurrent with $o_{n+1}$ and that insert at a position within the interval from $\mathit{prev}$ to $\mathit{next}$. By the induction hypothesis, all possible sub-histories $H_c$ result in the same final order of list elements within that interval. The operations in $H_c$ do not affect (and are not affected by) the list order outside of that interval, so we can consider $H_c$ in isolation.

Let $[\mathit{id}_1, \dots, \mathit{id}_k]$ be the Lamport timestamps of the list elements in the interval between $\mathit{prev}$ and $\mathit{next}$, in the list order unambiguously defined by $H_c$. We need to show that regardless at what position in $H_c$ we insert the operation $o_{n+1}$, the outcome is the same sequence of list elements $[\mathit{id}_1, \dots, \mathit{id}_m, \mathit{id}, \mathit{id}_{m+1}, \dots, \mathit{id}_k]$, where $\mathit{id}$ is the Lamport timestamp of $o_{n+1}$.

Since $\mathsf{insert}$ operations only add a new element between two existing, adjacent elements, it is sufficient to show that regardless where $o_{n+1}$ is inserted to $H_c$, the set of list elements $\{\mathit{id}_1, \dots, \mathit{id}_m\}$ that appear before $\mathit{id}$ in the final order is the same.

Note that the $\mathrm{apply}$ rule ensures that after $\mathit{id}$ is inserted, all list elements between $\mathit{prev}$ and the insertion point have an ID greater than $\mathit{id}$, and the list element following the insertion point has an ID less than $\mathit{id}$. Further note that by the definition of Lamport timestamps, any operation that causally depends on an operation $o_i$ must have a greater ID than $o_i$.

Let the set $T_\mathit{left} = \{\mathit{id}_i \mid \mathsf{insert}(\mathit{id}_i, \mathit{prev}, \placeholder) \in H_c\}$ contain the IDs of all operations in $H_c$ that use $\mathit{prev}$ as their reference position. Any history consisting only of these operations, in any order, results in the same final list order, namely in order of descending Lamport timestamp (TODO prove this in a lemma, it might not be obvious). Since Lamport timestamps are totally ordered, this list order is deterministic and unique. $\mathit{id}$ has a deterministic position within this order.

Any operation $o_i$ in $H_c$ that uses a different list element (not $\mathit{prev}$) as its reference position appears at some position after its reference element in the final list order, and has a Lamport timestamp greater than its reference element. If the reference element appears after $o_{n+1}$ in the final order, $o_i$ also appears after $o_{n+1}$, regardless of the order in which operations are applied.

If the reference element appears before $o_{n+1}$ in the final order, that means the timestamp of the reference element is greater than $\mathit{id}$, and so the timestamp of $o_i$ is also greater than $\mathit{id}$. If $o_{n+1}$ appears after $o_i$ in the history, then the apply rule for $o_{n+1}$ skips over both $o_i$ and the reference element. If $o_i$ appears after $o_{n+1}$ in the history, the apply rule for $o_i$ does not skip over the list element for $o_{n+1}$, again because the timestamp for $o_i$ is greater than $\mathit{id}$. Either way, if the reference element appears before $o_{n+1}$ in the final order, so does $o_i$, regardless of the order in which operations are applied.

TODO that last bit of the argument is a bit hand-wavy, need to make it more precise. But I think the general approach is ok. That completes the induction step, and thus the proof.

{\footnotesize
\bibliographystyle{plainnat}
\bibliography{references}{}}
\end{document}
